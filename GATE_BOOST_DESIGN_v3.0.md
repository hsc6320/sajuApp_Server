# LLM 의미 판정 구조 (v4.0) 🎯

## 🔄 v4.0 변경사항: Rule/마커 제거 → LLM 위임

### 이전 방식 (v3.0)의 한계
```
❌ Gate(판단형 키워드) + Boost(마커) 구조
❌ "둘중에 하나만 고르라면?" → 놓침
❌ 키워드가 없으면 의미 파악 불가
```

### 새로운 방식 (v4.0)
```
✅ 모든 회귀 판정을 LLM에 위임
✅ 의미 기반 판정 (키워드 불필요)
✅ 보수적 임계치 유지 (confidence ≥ 0.75)
```

---

## 📐 최종 Pipeline

```
User Question
   ↓
[Step A] LLM 회귀 판정 (의미 기반)
   ↓ (is_continuation=True AND confidence ≥ 0.75)
[Step B] LLM 결론 정제 (이미 나온 판단만)
   ↓ (confidence ≥ 0.6)
[Step C] 조건부 주입 (1~3줄)
   ↓
메인 LLM 응답
```

---

## 🎯 Step A: LLM 회귀 판정

### 프롬프트
```
너는 "대화 회귀 여부 판정기"다.
현재 질문이 직전 답변을 전제로 의미적으로 이어지는지 판정하라.

규칙:
- 추측 금지. 텍스트 근거가 약하면 False.
- "이전 답변을 전제" 하면 True.
- 완전히 새 주제면 False.

출력:
{
  "is_continuation": true/false,
  "confidence": 0.0-1.0,
  "reason": "한 문장"
}
```

### 임계치
```python
confidence >= 0.75 → 회귀 판정 ✅
confidence < 0.75 → 즉시 종료 ❌
```

---

## 📊 실제 케이스 분석

### ✅ 케이스 1: "둘중에 하나만 고르라면?"

**입력**:
```
직전 답변: "2027년은 직장생활과 사업 모두 긍정적..."
현재 질문: "둘중에 하나만 고르라면?"
```

**LLM 판정**:
```json
{
  "is_continuation": true,
  "confidence": 0.95,
  "reason": "이전 답변에서 제시한 두 선택지(직장/사업) 중 하나를 고르라는 후속 질문"
}
```

**결과**: confidence 0.95 ≥ 0.75 → ✅ 회귀

---

### ✅ 케이스 2: "왜?" (판단형 답변 후)

**입력**:
```
직전 답변: "직장을 우선하는 게 좋습니다"
현재 질문: "왜?"
```

**LLM 판정**:
```json
{
  "is_continuation": true,
  "confidence": 0.90,
  "reason": "이전 권장사항에 대한 근거를 묻는 질문"
}
```

**결과**: ✅ 회귀

---

### ❌ 케이스 3: 완전히 새 주제

**입력**:
```
직전 답변: "직장생활이 좋습니다"
현재 질문: "내년 건강운은?"
```

**LLM 판정**:
```json
{
  "is_continuation": false,
  "confidence": 0.15,
  "reason": "완전히 다른 주제(건강)로 전환"
}
```

**결과**: ❌ 비회귀

---

## 🔍 로그 출력

### Step A 로그
```
[REG][STEP-A] is_continuation=True confidence=0.95 
              reason='이전 답변에서 제시한 두 선택지 중 하나를 고르라는 후속 질문'
```

### 디버그 필드
```python
{
  "step": "A",
  "is_continuation": True,
  "confidence": 0.95,
  "reason": "...",
  "below_threshold": False
}
```

---

## ✅ v4.0의 장점

| 항목 | v3.0 (Rule) | v4.0 (LLM) |
|------|-------------|------------|
| "둘중에 하나만" | ❌ 놓침 | ✅ 감지 |
| "고르라면?" | ❌ 놓침 | ✅ 감지 |
| 유지보수 | 키워드 추가 필요 | 불필요 |
| 새로운 패턴 | 룰 추가 필요 | 자동 대응 |
| 의미 이해 | 제한적 | 강력 |

---

## 🎓 구현 원칙 (변경 없음)

### Step B: 결론 정제
- 텍스트에 없는 내용 생성 금지
- 불확실하면 빈 배열
- confidence ≥ 0.6

### Step C: 주입
- 1~3줄 제한
- 자연스러운 문체
- 태그 형식 피하기

---

## 🚀 테스트 시나리오 (v4.0)

### 시나리오 1: 의미 기반 회귀
```
Q1: "2027년 직장생활이 나아? 사업이 나아?"
A1: "둘 다 긍정적..."

Q2: "둘중에 하나만 고르라면?"
[STEP-A] confidence=0.95 → ✅ 회귀 감지
[STEP-B] refined 결과 확인
[STEP-C] 이전 결론 주입 확인
```

### 시나리오 2: 보수적 스킵
```
Q1: "..."
A1: "..."

Q2: "건강운은?" (완전히 새 주제)
[STEP-A] confidence=0.20 < 0.75 → ❌ 비회귀
즉시 종료 ✅
```

---

## 📝 수정 완료 파일

1. ✅ `functions/regress_Deixis.py`
   - `_is_continuation_by_structure()` 제거
   - `_llm_detect_continuation_v2()` 추가
   - Gate/Boost 로직 완전 제거
   - LLM 의미 판정으로 대체
   - 임계치: confidence ≥ 0.75

---

## 🎯 핵심 정리

### 설계 철학
```
✅ LLM이 의미로 판단 (키워드 불필요)
✅ 보수적 임계치 (0.75)
✅ 룰/마커 유지보수 부담 제거
```

### 비용
```
- Step A LLM 호출: 매번 (짧은 프롬프트, gpt-4o-mini)
- 예상 증가: 미미 (기존에도 회귀 시 LLM 2회 호출)
```

### 효과
```
✅ "둘중에 하나만" → 감지
✅ "고르라면?" → 감지
✅ 새로운 패턴 → 자동 대응
✅ 유지보수 → 제로
```

---

**버전**: 4.0  
**구현일**: 2026-01-04  
**핵심**: Rule/마커 제거 → LLM 의미 판정 위임  
**임계치**: 0.75 (보수적)


---

## 📐 점수 체계

### A. 상황 점수 (Gate) - 최대 1.00

| 항목 | 조건 | 점수 | 설명 |
|------|------|------|------|
| **판단형 답변** | 직전 assistant에 "권장/추천/결론/바람직" | **+0.55** | 상황의 뿌리 |
| **짧은 질문** | 길이 < 15 AND 판단형 | **+0.25** | 맥락 전제 |
| **명시적 참조** | "아까/전에/말한/말씀" | **+0.20** | 강한 신호 |

### B. 마커 점수 (Boost) - 최대 0.20 (cap)

| 마커 유형 | 예시 | 점수 | 비고 |
|-----------|------|------|------|
| 연결어 | "그럼", "그러면", "그런데" | +0.05 | 약한 신호 |
| 후속 표현 | "왜", "언제", "더", "자세히" | +0.08 | 보조 |
| 결정 표현 | "하나만", "병행", "우선" | +0.10 | 중간 |
| 비교 표현 | "가능성", "확률", "비교" | +0.08 | 보조 |

**중요**: 마커가 여러 개 있어도 **총합 0.20 이상은 불가** (cap)

---

## 🎯 임계치

```python
confidence >= 0.60 → is_continuation = True
```

**보수적 설정**: 애매한 경우 회귀 안 함

---

## 📊 시뮬레이션 (제안 기준)

### ✅ 케이스 1: 판단형 답변 후 "왜?"

```
A: "직장을 우선하는 게 바람직합니다" (판단형)
Q: "왜?" (짧음)

상황 점수:
  prev_is_decision: +0.55
  short_after_decision: +0.25
마커 점수:
  follow_up(왜): +0.08
  
총점: 0.88 ≥ 0.60 → ✅ 회귀
```

**분석**: 마커 없어도 0.80 → 이미 회귀

---

### ✅ 케이스 2: 판단형 답변 후 "그럼?"

```
A: "권장합니다" (판단형)
Q: "그럼?" (짧음)

상황: 0.55 + 0.25 = 0.80
마커: 0.05 (connective)

총점: 0.85 ≥ 0.60 → ✅ 회귀
```

---

### ❌ 케이스 3: 일반 대화 중 "그럼?"

```
A: "날씨가 좋습니다" (판단형 아님)
Q: "그럼?" (짧음)

상황: 0.00 (판단형 없음)
마커: 0.05

총점: 0.05 < 0.60 → ❌ 비회귀
```

**의도대로 작동**: 보수적

---

### ✅ 케이스 4: "아까 말한 거 병행?"

```
A: "직장 우선이 좋습니다" (판단형)
Q: "아까 말한 거 병행?" (짧음)

상황:
  prev_is_decision: 0.55
  short_after_decision: 0.25
  explicit_reference(아까, 말한): 0.20
마커:
  decision(병행): 0.10 → cap 적용으로 0.00 (이미 1.00)

총점: 1.00 ≥ 0.60 → ✅ 회귀
```

---

### ❌ 케이스 5: 마커만 많은 경우

```
A: "날씨 설명..." (판단형 아님)
Q: "그럼 언제쯤 병행하면 좋을까요?"

상황: 0.00
마커:
  connective(그럼): 0.05
  follow_up(언제): 0.08
  decision(병행): 0.10
  → 합계 0.23 → cap 0.20

총점: 0.20 < 0.60 → ❌ 비회귀
```

**의도대로 작동**: 마커만으로는 회귀 불가

---

## 🔍 로그 출력 (디버깅용)

### 정상 로그
```
[REG][STEP-A] is_continuation=True confidence=0.85 
              (situation=0.80 + markers=0.05) 
              signals=['prev_is_decision', 'short_after_decision', 'connective:그럼']
```

### breakdown 필드
```python
{
  "breakdown": {
    "situation": 0.80,      # Gate 점수
    "markers": 0.05,        # Boost 점수 (cap 적용 후)
    "markers_raw": 0.05     # cap 적용 전
  }
}
```

### cap 적용 시
```
[REG][STEP-A] signals=[..., 'marker_capped(0.23→0.20)']
```

---

## 🎓 구현 원칙 3개 (중요!)

### 1️⃣ **짧은 질문 점수는 조건부**
```python
# ❌ 무조건 점수
if is_short:
    score += 0.25

# ✅ 조건부 (판단형일 때만)
if is_short and prev_is_decision:
    score += 0.25
```

---

### 2️⃣ **마커 합산은 반드시 cap**
```python
marker_score = 0.0
# ... 마커들 점수 누적 ...

MARKER_CAP = 0.20
marker_score_capped = min(marker_score, MARKER_CAP)
```

**이유**: 마커를 쌓아서 회귀를 만들어내지 못하게

---

### 3️⃣ **판단형 판별은 강하게**
```python
DECISION_STRONG = [
    "권장", "추천", "우선", "결론", "방향", "선택", 
    "바람직", "적합", "좋습니", "나쁩니", "주의"
]

# ❌ 정보 설명은 판단형 아님
"올해는 재물운이 좋습니다" → NOT 판단형 (단순 서술)
"올해 재물운이 좋으니 투자를 권장합니다" → 판단형 ✅
```

---

## 📊 개선 전/후 비교

| 케이스 | v2.1 (마커 주도) | v3.0 (Gate+Boost) |
|--------|------------------|-------------------|
| "왜?" (판단형 후) | 0.25 + 0.20 = 0.45 ❌ | 0.55 + 0.25 + 0.08 = 0.88 ✅ |
| "그럼?" (일반) | 0.25 + 0.15 = 0.40 ❌ | 0.05 ❌ (의도대로) |
| "아까?" (단독) | 0.30 + 0.15 = 0.45 ❌ | 0.20 ❌ (보수적) |
| 마커 많음 (일반) | 0.80 ✅ (오탐) | 0.20 ❌ (cap) |

---

## 🚀 테스트 시나리오

### 시나리오 1: 정상 회귀 (판단형 → 짧은 질문)
```
Q1: "26년 직장 vs 사업"
A1: "직장을 우선하는 게 바람직합니다"

Q2: "왜?"
[STEP-A] 
  situation=0.80 (prev_decision=0.55 + short=0.25)
  markers=0.08 (follow_up:왜)
  confidence=0.88
  is_continuation=True ✅

로그 확인:
✅ breakdown.situation ≥ 0.50
✅ signals=['prev_is_decision', 'short_after_decision', 'follow_up:왜']
```

---

### 시나리오 2: 보수적 스킵 (판단형 없음)
```
Q1: "날씨 어때?"
A1: "날씨가 좋습니다" (판단형 아님)

Q2: "그럼 언제 병행?"
[STEP-A]
  situation=0.00 (판단형 없음)
  markers=0.20 (cap)
  confidence=0.20
  is_continuation=False ✅

로그 확인:
✅ breakdown.situation = 0
✅ confidence < 0.60
```

---

### 시나리오 3: 명시적 참조 (강한 신호)
```
Q1: "사업 어때?"
A1: "긍정적입니다"

Q2: "아까 말씀하신 사업 시작은?"
[STEP-A]
  situation=0.20 (explicit_reference)
  markers=0.10 (decision:시작)
  confidence=0.30
  is_continuation=False ✅ (판단형 없어서 0.60 미만)

만약 A1이 "사업을 권장합니다"였다면:
  situation=0.55+0.20=0.75
  confidence=0.85 ✅
```

---

## 📝 수정 완료 파일

1. ✅ `functions/regress_Deixis.py`
   - Gate(상황) + Boost(마커) 구조 구현
   - 점수 체계 재설계:
     - prev_is_decision: 0.55
     - short_after_decision: 0.25
     - explicit_reference: 0.20
     - 마커 cap: 0.20
   - 임계치: 0.60
   - breakdown 필드 추가 (디버깅)

---

## 🎯 핵심 정리

### 설계 의도
```
✅ 판단형 답변 후 → 회귀 (마커 무관)
❌ 일반 대화 중 마커만 → 비회귀
✅ 명시적 참조("아까") → 강한 신호
❌ 마커 많아도 cap → 오탐 방지
```

### 마커의 역할
```
주 수단 ❌
보조 수단 ✅
가중치 제공 (최대 0.20)
```

### 실전 패턴
```
[60%] 판단형 → 짧은 질문 (마커 보조)
[30%] 명시적 참조 + 판단형
[10%] 마커만 (비회귀, 보수적)
```

---

**버전**: 3.0  
**구현일**: 2026-01-04  
**핵심**: Gate(상황) + Boost(마커), 보수적 임계치 0.60  
**마커 역할**: 보조 수단 (cap=0.20)

